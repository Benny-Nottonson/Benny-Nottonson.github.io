[
  {
    "published": true,
    "title": "appLab Whitelist Proxy",
    "description": "A proxy server to break AppLab, uses image manipulation and Nodejs",
    "date": "2023-05-30T00:00:00.000Z",
    "url": "https://github.com/benny-nottonson/applabWhitelistProxy",
    "repository": "benny-nottonson/applabWhitelistProxy",
    "body": {
      "raw": "\n\n`applabWhitelistProxy` is a program I created in order to break the sandbox built into code.org's AppLab",
      "code": "var Component=(()=>{var b=Object.create;var s=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,h=Object.prototype.hasOwnProperty;var m=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var o in e)s(t,o,{get:e[o],enumerable:!0})},i=(t,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of x(e))!h.call(t,r)&&r!==o&&s(t,r,{get:()=>e[r],enumerable:!(a=l(e,r))||a.enumerable});return t};var j=(t,e,o)=>(o=t!=null?b(u(t)):{},i(e||!t||!t.__esModule?s(o,\"default\",{value:t,enumerable:!0}):o,t)),g=t=>i(s({},\"__esModule\",{value:!0}),t);var c=m((A,p)=>{p.exports=_jsx_runtime});var P={};y(P,{default:()=>L,frontmatter:()=>_});var n=j(c()),_={title:\"appLab Whitelist Proxy\",description:\"A proxy server to break AppLab, uses image manipulation and Nodejs\",date:\"2023-05-30\",url:\"https://github.com/benny-nottonson/applabWhitelistProxy\",repository:\"benny-nottonson/applabWhitelistProxy\",published:!0};function d(t){let e=Object.assign({p:\"p\",code:\"code\"},t.components);return(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"applabWhitelistProxy\"}),\" is a program I created in order to break the sandbox built into code.org's AppLab\"]})}function f(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var L=f;return g(P);})();\n;return Component;"
    },
    "_id": "projects/appLabWhitelistProxy.mdx",
    "_raw": {
      "sourceFilePath": "projects/appLabWhitelistProxy.mdx",
      "sourceFileName": "appLabWhitelistProxy.mdx",
      "sourceFileDir": "projects",
      "contentType": "mdx",
      "flattenedPath": "projects/appLabWhitelistProxy"
    },
    "type": "Project",
    "path": "/projects/appLabWhitelistProxy",
    "slug": "appLabWhitelistProxy"
  },
  {
    "published": true,
    "title": "Spotify Sort",
    "description": "A Python app that uses Color Coherence Vectors in order to sort Spotify Playlists",
    "date": "2023-02-08T00:00:00.000Z",
    "url": "https://github.com/benny-nottonson/spotifySort",
    "repository": "benny-nottonson/spotifySort",
    "body": {
      "raw": "\n`Spotify Sort` is a Python utility intended to sort Spotify playlists by the color of their album covers. Using Color Coherency Vectors proved to be the most accurate, after applying loop sorting over multiple iterations to find the shortest overall distance between all vectors. A Self-Organization Map was originally used, but it was not efficient or accurate.\n\nSpotify Sort is publically avaialable and should work on Python 3.9+\n",
      "code": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var h=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var b=(t,o)=>()=>(o||t((o={exports:{}}).exports,o),o.exports),m=(t,o)=>{for(var n in o)s(t,n,{get:o[n],enumerable:!0})},a=(t,o,n,i)=>{if(o&&typeof o==\"object\"||typeof o==\"function\")for(let r of u(o))!f.call(t,r)&&r!==n&&s(t,r,{get:()=>o[r],enumerable:!(i=y(o,r))||i.enumerable});return t};var S=(t,o,n)=>(n=t!=null?d(h(t)):{},a(o||!t||!t.__esModule?s(n,\"default\",{value:t,enumerable:!0}):n,t)),g=t=>a(s({},\"__esModule\",{value:!0}),t);var l=b((w,c)=>{c.exports=_jsx_runtime});var v={};m(v,{default:()=>_,frontmatter:()=>x});var e=S(l()),x={title:\"Spotify Sort\",description:\"A Python app that uses Color Coherence Vectors in order to sort Spotify Playlists\",date:\"2023-02-08\",url:\"https://github.com/benny-nottonson/spotifySort\",repository:\"benny-nottonson/spotifySort\",published:!0};function p(t){let o=Object.assign({p:\"p\",code:\"code\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(o.p,{children:[(0,e.jsx)(o.code,{children:\"Spotify Sort\"}),\" is a Python utility intended to sort Spotify playlists by the color of their album covers. Using Color Coherency Vectors proved to be the most accurate, after applying loop sorting over multiple iterations to find the shortest overall distance between all vectors. A Self-Organization Map was originally used, but it was not efficient or accurate.\"]}),`\n`,(0,e.jsx)(o.p,{children:\"Spotify Sort is publically avaialable and should work on Python 3.9+\"})]})}function j(t={}){let{wrapper:o}=t.components||{};return o?(0,e.jsx)(o,Object.assign({},t,{children:(0,e.jsx)(p,t)})):p(t)}var _=j;return g(v);})();\n;return Component;"
    },
    "_id": "projects/spotifySort.mdx",
    "_raw": {
      "sourceFilePath": "projects/spotifySort.mdx",
      "sourceFileName": "spotifySort.mdx",
      "sourceFileDir": "projects",
      "contentType": "mdx",
      "flattenedPath": "projects/spotifySort"
    },
    "type": "Project",
    "path": "/projects/spotifySort",
    "slug": "spotifySort"
  },
  {
    "published": true,
    "title": "tensorflowImageMorpher",
    "description": "A tensorflow project to morph from image to image using morph maps",
    "date": "2022-06-01T00:00:00.000Z",
    "url": "https://github.com/benny-nottonson/tensorflowImageMorpher",
    "repository": "benny-nottonson/tensorflowImageMorpher",
    "body": {
      "raw": "\n`tensorflowImageMorpher` is a program written in Python 3.11 that uses Tensorflow to morph between a set of images.\nBy training the model to recognize the edges and colors of different images, the model is able to generate a warp map\nthat is then used to shift from image to image in a set ammount of steps.",
      "code": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty;var u=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),w=(e,t)=>{for(var o in t)s(e,o,{get:t[o],enumerable:!0})},i=(e,t,o,a)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of g(t))!l.call(e,r)&&r!==o&&s(e,r,{get:()=>t[r],enumerable:!(a=f(t,r))||a.enumerable});return e};var x=(e,t,o)=>(o=e!=null?h(d(e)):{},i(t||!e||!e.__esModule?s(o,\"default\",{value:e,enumerable:!0}):o,e)),b=e=>i(s({},\"__esModule\",{value:!0}),e);var p=u((C,m)=>{m.exports=_jsx_runtime});var _={};w(_,{default:()=>y,frontmatter:()=>j});var n=x(p()),j={title:\"tensorflowImageMorpher\",description:\"A tensorflow project to morph from image to image using morph maps\",date:\"2022-06-01\",url:\"https://github.com/benny-nottonson/tensorflowImageMorpher\",repository:\"benny-nottonson/tensorflowImageMorpher\",published:!0};function c(e){let t=Object.assign({p:\"p\",code:\"code\"},e.components);return(0,n.jsxs)(t.p,{children:[(0,n.jsx)(t.code,{children:\"tensorflowImageMorpher\"}),` is a program written in Python 3.11 that uses Tensorflow to morph between a set of images.\nBy training the model to recognize the edges and colors of different images, the model is able to generate a warp map\nthat is then used to shift from image to image in a set ammount of steps.`]})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,n.jsx)(t,Object.assign({},e,{children:(0,n.jsx)(c,e)})):c(e)}var y=M;return b(_);})();\n;return Component;"
    },
    "_id": "projects/tensorflowImageMorpher.mdx",
    "_raw": {
      "sourceFilePath": "projects/tensorflowImageMorpher.mdx",
      "sourceFileName": "tensorflowImageMorpher.mdx",
      "sourceFileDir": "projects",
      "contentType": "mdx",
      "flattenedPath": "projects/tensorflowImageMorpher"
    },
    "type": "Project",
    "path": "/projects/tensorflowImageMorpher",
    "slug": "tensorflowImageMorpher"
  },
  {
    "published": true,
    "title": "This Site!",
    "description": "A next.js portfolio site.",
    "date": "2023-06-01T00:00:00.000Z",
    "url": "https://bennnyottonson.com",
    "repository": "benny-nottonson/benny-nottonson.github.io",
    "body": {
      "raw": "",
      "code": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var l=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),h=(t,n)=>{for(var e in n)s(t,e,{get:n[e],enumerable:!0})},a=(t,n,e,i)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of b(n))!f.call(t,r)&&r!==e&&s(t,r,{get:()=>n[r],enumerable:!(i=x(n,r))||i.enumerable});return t};var j=(t,n,e)=>(e=t!=null?p(d(t)):{},a(n||!t||!t.__esModule?s(e,\"default\",{value:t,enumerable:!0}):e,t)),y=t=>a(s({},\"__esModule\",{value:!0}),t);var c=l((F,u)=>{u.exports=_jsx_runtime});var C={};h(C,{default:()=>M,frontmatter:()=>_});var o=j(c()),_={title:\"This Site!\",description:\"A next.js portfolio site.\",date:\"2023-06-01\",url:\"https://bennnyottonson.com\",repository:\"benny-nottonson/benny-nottonson.github.io\",published:!0};function m(t){return(0,o.jsx)(o.Fragment,{})}function g(t={}){let{wrapper:n}=t.components||{};return n?(0,o.jsx)(n,Object.assign({},t,{children:(0,o.jsx)(m,t)})):m(t)}var M=g;return y(C);})();\n;return Component;"
    },
    "_id": "projects/website.mdx",
    "_raw": {
      "sourceFilePath": "projects/website.mdx",
      "sourceFileName": "website.mdx",
      "sourceFileDir": "projects",
      "contentType": "mdx",
      "flattenedPath": "projects/website"
    },
    "type": "Project",
    "path": "/projects/website",
    "slug": "website"
  }
]